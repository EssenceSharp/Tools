'From Pharo3.0 of 18 March 2013 [Latest update: #30850] on 18 July 2014 at 2:05:48.081869 pm'!Object subclass: #EssenceClassLibraryExporter	instanceVariableNames: 'essenceNamespacePath localNamespace ignoreTraits'	classVariableNames: 'LibraryPath LibraryPathPrefix PathnameDelimiter'	poolDictionaries: ''	category: 'Essence'!!EssenceClassLibraryExporter commentStamp: '<historical>' prior: 0!!!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 18:17'!qualifiedEssenceNamespaceName: qualifiedNamespaceName localNamespace: aLocalNamespace		self 		essenceNamespacePath: (self pathElementsOf: qualifiedNamespaceName separator: $.); 		localNamespace: aLocalNamespace	! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 18:17'!essenceNamespacePath	^essenceNamespacePath! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 17:20'!localNamespace: aLocalNamespace	localNamespace := aLocalNamespace ifNil: [Smalltalk]! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 17:22'!organization	^self localNamespace  organization! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 18:17'!essenceNamespacePath: aSequenceOfStrings	| size newPath |	size := aSequenceOfStrings size.	newPath := Array new: size.	1 to: size do: [:index | newPath at: index put: (aSequenceOfStrings at: index) asString].	essenceNamespacePath := newPath.! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 16:34'!willIgnoreTraits	^ignoreTraits! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 18:42'!outputPathname		^self class constructPathnameFromPrefix: self class libraryPathname path: self essenceNamespacePath! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/18/2014 14:03'!ignoreTraits: aBoolean		"The <ignoreTraits> instance variable controls whether or not any trait usage statment is emitted, 		and whether or not the methods imported from traits are emitted or excluded. 'True' means that		no trait usage statement will be emitted, and the methods imported by way of trait usage WILL BE		INCLUDED in the methods of the exported class or trait. The default value is FALSE."	ignoreTraits := aBoolean = true! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 16:32'!ignoreTraits	^ignoreTraits! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 17:19'!localNamespace	^localNamespace! !!EssenceClassLibraryExporter methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 18:17'!qualifiedEssenceNamespaceName	| writeStream |	writeStream := (String new: 16) writeStream.	self essenceNamespacePath do: [:pathElement | ] separatedBy: [writeStream nextPut: $.]	! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AlanLovejoy 7/2/2014 04:52'!protocolsOf: aBehavior	^aBehavior organization categoriesSorted reject: [ :each | each = '-- all --' ]! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AL 7/1/2014 23:22'!pathElementsOf: aString separator: separator	^aString findTokens: separator! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AlanLovejoy 7/2/2014 12:42'!newWriteStream: pathname	| fn |	fn := pathname asFileReference.	fn parent ensureCreateDirectory.	fn exists ifTrue: [fn delete].	^fn writeStream! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AlanLovejoy 7/2/2014 19:20'!selectorsOf: aBehavior inProtocol: protocol	| selectors |	selectors := (aBehavior organization listAtCategoryNamed: protocol) asSortedCollection.	^ignoreTraits		ifTrue: [selectors]		ifFalse: 			[| localSelectors |			localSelectors := aBehavior localSelectors.			selectors select: [:selector | localSelectors includes: selector]]! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AlanLovejoy 7/2/2014 03:14'!withoutEnclosingWhitespace: aString	^aString trimBoth! !!EssenceClassLibraryExporter methodsFor: 'inter-Smalltalk compatibility' stamp: 'AL 7/1/2014 23:42'!linesOf: aString	^aString lines! !!EssenceClassLibraryExporter methodsFor: 'initailize-release' stamp: 'AlanLovejoy 7/2/2014 16:36'!initialize	ignoreTraits := false! !!EssenceClassLibraryExporter methodsFor: 'private' stamp: 'AL 7/1/2014 22:59'!instanceArchitectureOf: aClass	aClass isMeta ifTrue: [^#Class].	^aClass isVariable		ifTrue: 			[aClass isBits				ifTrue: [aClass isBytes ifTrue: [#IndexedByteSlots] ifFalse: [#IndexedWordSlots]]				ifFalse: [#IndexedObjectSlots]]		ifFalse: [#NamedSlots]! !!EssenceClassLibraryExporter methodsFor: 'private' stamp: 'AL 7/1/2014 23:30'!initializerValueStringFor: aValue	(aValue isNumber or: [aValue isString or: [(aValue isKindOf: Boolean) or: [aValue isCharacter]]]) ifTrue: [^aValue printString].	^'nil'! !!EssenceClassLibraryExporter methodsFor: 'private' stamp: 'AlanLovejoy 7/2/2014 19:29'!emitTraitUsageMessageFor: aBehavior on: stream	stream nextPutAll: 'uses: '.	aBehavior traitComposition printOn: stream! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 18:42'!exportInitializationOf: aClass	| pathname stream  |		pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aClass name with: 'class.initialize').	stream := self newWriteStream: pathname.	[stream		tab;		nextPutAll: '"Initialization of ';		nextPutAll: aClass name;		nextPut: $";		cr; cr; tab;		nextPutAll: 'initialize'] ensure: [stream close]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 22:53'!exportTraitDefinition: aTrait	| pathname stream   |		pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aTrait name with: 'trait.configure').	stream := self newWriteStream: pathname.	[stream		tab;		nextPutAll: '"Configuration of  ';		nextPutAll: aTrait name;		nextPut: $".	aTrait hasTraitComposition		ifTrue: 			[stream				cr; cr; tab.			self emitTraitUsageMessageFor: aTrait on: stream]]		ensure: [stream close]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/18/2014 14:05'!exportMethodIn: protocol source: source on: stream	| lines |	stream		tab;		nextPutAll: 'protocol: ';		nextPutAll: protocol asSymbol printString;		nextPutAll: ' method:';		cr; cr; tab;		nextPutAll: '[## '.	lines := self linesOf: (self withoutEnclosingWhitespace: source asString).	stream nextPutAll: (lines at: 1).	2 to: lines size do: 		[:index | 			stream 				cr; tab: 2;				nextPutAll: (lines at: index)].	stream cr; tab; nextPut: $]	! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 23:01'!exportClassDefinition: aClass	| pathname stream superclass instanceArchitecture instVarNames  |		superclass := aClass superclass.	instanceArchitecture := self instanceArchitectureOf: aClass.	instVarNames := aClass instVarNames.	pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aClass name with: 'class.configure').	stream := self newWriteStream: pathname.	[stream		tab;		nextPutAll: '"Configuration of the instance architecture, initial state and module memberships of ';		nextPutAll: aClass name;		nextPut: $";		cr; cr; tab;		nextPutAll: 'superclass: ';		nextPutAll: (superclass ifNil: ['nil'] ifNotNil: [superclass name]);		nextPut: $;;		cr; tab;		nextPutAll: 'instanceArchitecture: ';		nextPutAll: instanceArchitecture printString.		instVarNames size > 0			ifTrue: 				[stream					nextPut: $;;					cr; tab;					nextPutAll: 'instanceVariableNames: #('.				instVarNames do: [:each | stream nextPutAll: each] separatedBy: [stream space].				stream nextPut: $)].	ignoreTraits 		ifFalse: 			[aClass hasTraitComposition				ifTrue: 					[stream						nextPut: $;;						cr; tab.					self emitTraitUsageMessageFor: aClass on: stream]] ] 		ensure: [stream close]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 18:42'!exportClassVariablesOf: aClass	| pathnamePrefix |	pathnamePrefix := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aClass name).	aClass classPool keysAndValuesDo: 		[:key :value | self exportVariableDefinition: key value: value pathPrefix: pathnamePrefix].	! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 23:10'!exportMetaclassDefinition: aMetaclass	| pathname stream instVarNames nextRequiresCascadeContinuation |		instVarNames := aMetaclass instVarNames.	pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aMetaclass soleInstance name with: 'metaclass.configure').	stream := self newWriteStream: pathname.	[stream		tab;		nextPutAll: '"Configuration of the instance architecture, initial state and module memberships of ';		nextPutAll: aMetaclass name;		nextPut: $".		nextRequiresCascadeContinuation := false.		instVarNames size > 1			ifTrue: 				[nextRequiresCascadeContinuation = true.				stream					cr; cr; tab;					nextPutAll: 'instanceVariableNames: ';					nextPutAll: instVarNames storeString].	ignoreTraits 		ifFalse: 			[aMetaclass hasTraitComposition				ifTrue: 					[nextRequiresCascadeContinuation ifTrue: [stream nextPut: $;].					stream cr; cr; tab.					self emitTraitUsageMessageFor: aMetaclass on: stream]]] ensure: [stream close] ! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AL 4/26/2014 05:01'!exportVariableDefinition: name value: value pathPrefix: pathPrefix	| pathname stream |	pathname := 		self class				constructPathnameFromPrefix: pathPrefix				path: (Array with: name, '.variable').	stream := self newWriteStream: pathname.	[stream 		tab;		nextPutAll: 'accessPrivilege: #InHierarchy;';		cr; tab;		nextPutAll: 'value: ';		nextPutAll: (self initializerValueStringFor: value)] ensure: [stream close]	! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AL 4/26/2014 04:46'!exportClass: aClass	| metaclass |	self 		exportClassDefinition: aClass;		exportClassVariablesOf: aClass;		exportMethodsOf: aClass.	metaclass := aClass class.	self 		exportMetaclassDefinition: metaclass;		exportMethodsOf: metaclass.	(metaclass includesSelector: #initialize)		ifTrue: [self exportInitializationOf: aClass]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 22:30'!exportTrait: aTrait	| classTrait |	self 		exportTraitDefinition: aTrait;		exportClassVariablesOf: aTrait;		exportMethodsOf: aTrait.	classTrait := aTrait classTrait.	self 		exportClassTraitDefinition: classTrait;		exportMethodsOf: classTrait! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 22:27'!exportClassCategory: classCategoryName		(self organization listAtCategoryNamed: classCategoryName asSymbol)		do: [:name | 			| categoryElement |			categoryElement := self localNamespace at: name.			categoryElement isTrait				ifTrue: [self exportTrait: categoryElement]				ifFalse: [self exportClass: categoryElement]]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 23:09'!exportClassTraitDefinition: aClassTrait	| pathname stream  |		pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array with: aClassTrait soleInstance name with: 'classTrait.configure').	stream := self newWriteStream: pathname.	[stream		tab;		nextPutAll: '"Configuration of ';		nextPutAll: aClassTrait name;		nextPut: $".	aClassTrait hasTraitComposition		ifTrue: 			[stream				cr; cr; tab.			self emitTraitUsageMessageFor: aClassTrait on: stream]] ensure: [stream close]! !!EssenceClassLibraryExporter methodsFor: 'exporting' stamp: 'AlanLovejoy 7/2/2014 23:34'!exportMethodsOf: aBehavior 	| isMeta className pathname stream nextRequiresCascadeContinuation |	isMeta := aBehavior isMeta.	className := isMeta ifTrue: [aBehavior soleInstance name] ifFalse: [aBehavior name].	pathname := 		self class				constructPathnameFromPrefix: self outputPathname				path: (Array						with: className						with: (isMeta								ifTrue: ['methods.class']								ifFalse: ['methods.instance'])).	stream := self newWriteStream: pathname.	[stream 		tab; 		nextPut: $";		nextPutAll: (isMeta ifTrue: ['Class'] ifFalse: ['Instance']); 		nextPutAll: ' methods for '; 		nextPutAll: className; 		nextPut: $"; 		cr; cr.	(self protocolsOf: aBehavior)		do: [:protocol | 				nextRequiresCascadeContinuation := false.				(self selectorsOf: aBehavior inProtocol: protocol)					do: [:selector | 						self							exportMethodIn: protocol							source: (aBehavior sourceCodeAt: selector) asString							on: stream.						nextRequiresCascadeContinuation := true]				separatedBy: 					[stream nextPut: $;; cr; cr]]		separatedBy: [nextRequiresCascadeContinuation ifTrue: [stream nextPut: $;; cr; cr]]] 			ensure: [stream close]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EssenceClassLibraryExporter class	instanceVariableNames: ''!!EssenceClassLibraryExporter class commentStamp: '<historical>' prior: 0!!!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 20:52'!libraryPath	^LibraryPath copy! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 21:03'!libraryPathPrefix: aString	LibraryPathPrefix := (aString ifNil: ['.']) asString copy! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 20:58'!libraryPath: anArrayOfStrings	| size newLibraryPath |	size := anArrayOfStrings size.	size < 1 		ifTrue:			[LibraryPath := #('.').			^self].	newLibraryPath := Array new: size.	1 to: size do: 		[:index |			newLibraryPath at: index put: (anArrayOfStrings at: index) asString].	LibraryPath := newLibraryPath! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 21:02'!libraryPathPrefix	^LibraryPathPrefix copy! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 22:22'!pathnameDelimiter	^PathnameDelimiter! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AL 4/25/2014 22:23'!pathnameDelimiter: aChar	PathnameDelimiter := aChar ifNil: [self defaultPathnameDelimiter]! !!EssenceClassLibraryExporter class methodsFor: 'accessing' stamp: 'AlanLovejoy 7/2/2014 16:51'!libraryPathname	"EssenceClassLibraryExporter libraryPathPrefix: '/Users/chronos/Documents/DEV/Smalltalk/EssenceSharp/Source/Libraries/'"	"EssenceClassLibraryExporter libraryPath: #('Pharo')"		"EssenceClassLibraryExporter libraryPathname"		^self constructPathnameFromPrefix: self libraryPathPrefix path: self libraryPath! !!EssenceClassLibraryExporter class methodsFor: 'instance creation' stamp: 'AlanLovejoy 7/2/2014 18:08'!exportingTo: qualifiedNamespaceName from: localNamespace	^self new 		qualifiedEssenceNamespaceName: qualifiedNamespaceName		localNamespace: localNamespace! !!EssenceClassLibraryExporter class methodsFor: 'instance creation' stamp: 'AlanLovejoy 7/2/2014 18:08'!exportingTo: qualifiedNamespaceName from: localNamespace ignoringTraits: shouldIgnoreTraits	^self new 		qualifiedEssenceNamespaceName: qualifiedNamespaceName		localNamespace: localNamespace;		ignoreTraits: shouldIgnoreTraits 		"The <shouldIgnoreTraits> parameter controls whether or not any trait usage statment is emitted, 		and whether or not the methods imported from traits are emitted or excluded. 'True' means that		no trait usage statement will be emitted, and the methods imported by way of trait usage WILL BE		INCLUDED in the methods of the exported class or class. The default value is FALSE."! !!EssenceClassLibraryExporter class methodsFor: 'examples' stamp: 'AlanLovejoy 7/2/2014 16:51'!exportSelf	"EssenceClassLibraryExporter exportSelf"		(self exportingTo: 'Utilities' from: Smalltalk)		exportClass: self! !!EssenceClassLibraryExporter class methodsFor: 'examples' stamp: 'AlanLovejoy 7/2/2014 19:37'!exportClassCategory	"EssenceClassLibraryExporter exportClassCategory"		(self exportingTo: 'SUnit' from: Smalltalk)		exportClassCategory: #'SUnit-Core-Kernel'! !!EssenceClassLibraryExporter class methodsFor: 'class initialization' stamp: 'AlanLovejoy 7/2/2014 16:51'!initialize	"EssenceClassLibraryExporter initialize"		PathnameDelimiter := self defaultPathnameDelimiter.	LibraryPathPrefix := '.'.	LibraryPath := #()! !!EssenceClassLibraryExporter class methodsFor: 'utilities' stamp: 'AlanLovejoy 7/2/2014 16:52'!exportClass: aClass to: essenceNamespaceName	"EssenceClassLibraryExporter exportClass: AbsolutePrice to: #TickTalk"		(self exportingTo: essenceNamespaceName from: aClass environment)		exportClass: aClass! !!EssenceClassLibraryExporter class methodsFor: 'utilities' stamp: 'AlanLovejoy 7/2/2014 16:55'!exportClassCategory: classCategory from: localNamespace to: essenceNamespaceName	"EssenceClassLibraryExporter exportClassCategory: #TickTalk from: Smalltalk to: #TickTalk"		(self exportingTo: essenceNamespaceName from: localNamespace)		exportClassCategory: classCategory! !!EssenceClassLibraryExporter class methodsFor: 'utilities' stamp: 'AlanLovejoy 7/2/2014 22:48'!exportTrait: aTrait to: essenceNamespaceName	"EssenceClassLibraryExporter exportTrait: TestAsserter to: #SUnit"		(self exportingTo: essenceNamespaceName from: aTrait environment)		exportTrait: aTrait! !!EssenceClassLibraryExporter class methodsFor: 'private' stamp: 'AL 4/28/2014 13:54'!constructPathnameFromPrefix: pathnamePrefix path: pathArray	| writeStream delimiter |	writeStream := (String new: 16) writeStream.	delimiter := self pathnameDelimiter.	writeStream nextPutAll: pathnamePrefix.	((pathnamePrefix endsWith: delimiter asString) or: [pathArray isEmpty])		ifFalse: [writeStream nextPut: delimiter].	pathArray		do: [:pathElement | writeStream nextPutAll: pathElement]		separatedBy: [writeStream nextPut: delimiter].	^writeStream contents	! !!EssenceClassLibraryExporter class methodsFor: 'private' stamp: 'AlanLovejoy 7/2/2014 02:44'!defaultPathnameDelimiter	^DiskStore delimiter! !EssenceClassLibraryExporter initialize!